# 概念

node是用于编写服务端应用；

使用JavaScript的核心语法；

区别于JavaScript，它的操作对象不一样：前端操作对象是浏览器对象，网络通讯（XMLHttpRequest/fetch）；后端的操作是os,process,fs,net(网络通讯)

API地址：

http://nodejs.cn/api/

https://nodejs.org/docs/latest/api/



# 运行调试模块

![image-20210507153549541](D:\File\Learning-Resource\images\vue\image-20210507153549541.png)

所有程序由模块组成，调试模块的方式：

* bash运行

  ```
  node helloworld/index.js
  或
  node helloworld
  ```

  

* nodemon自动重启

  监视代码修改，自动重启

  ```
  npm i nodemon -g //全局安装
  nodemon helloworld
  ```

* VScode调试debug

* 单元测试Jest

  安装jest库

  ```
  npm install jest -g
  ```

  在\__test\__文件夹中创建index.spec.js, 测试用例对应的是一个约定，

  ```
  test('hello world',()=>{
  	require(../index)
  })
  ```

  运行

  ```
  jest helloworld
  或
jest helloworld --watch //自动监控测试
  ```
  
  总结：
  
  ​    断点调试影响效率，一般不推荐，使用console.log日志化的方式或者使用单元测试。
  
  ​	index.js作为程序的功能；
  
  ​	index.spec.js完成测试用例，使用index.spec.js中的测试用例验证index.js方法正确与否
  
  
  
  ## 测试代码生成工具
  
  * 掌握fs中的同步方法
  * path包
  
  ## 文件名生成
  
  文件名生成工具
  
  TestNow/index.js
  
  ```
  const path=require('path')
  module.exports= class testnow{
      /**
       * 生成测试文件名
       * @param {*} filename 代码文件名
       */
      getfilename(filename){
          var dirname=path.dirname(filename)
          var basename=path.basename(filename)
          var extname=path.extname(filename)
          basename=basename.replace(extname,`.spec${extname}`)
          // return dirname+'/__test__/'+basename
          return path.format({
              root:dirname+'/__test__/',
              base:basename
          })
      }
  }
  ```
  
  编写测试用例
  
  TestNow/__test__/index.spec.js
  
  ```
  test('测试文件名生成',()=>{
      const src = new (require('../class'))()
      var ret= src.getfilename('/abc/class.js')
      expect(ret)
          .toBe('/abc/__test__/class.spec.js')
  })
  ```
  
  

检验测试结果

```
jest TestNow --watch
```

# 异步编程

## 串联异步处理

* callback 

  这是最古老的技术，但仍然是识别和理解的必不可少的技术，

  ```
  const result = document.getElementById('result');
  let approval='unapproval';
  function getApproval(callback){
    setTimeout(()=>{
       approval='Approved!'
       callback()
    } ,5)
  };
  getApproval(()=>{
    result.textContent=approval  
  });
  ```

  

* promise

  可能是当今使用最广泛的技术

  ```
  const result = document.getElementById('result');
  
  let approval = 'Not approved!';
  
  function getApproval() {
    return new Promise((resolve,reject)=>{
      setTimeout(()=>{resolve('approved!')}
                 ,50);
    }) ;
  };
  
  getApproval().then((resolvedapproved)=>{
    result.textContent=resolvedapproved;
  })
  ```

* gennerator

* async/await

  这两个小词使我们可以在等待异步代码完成时暂停执行代码。

  ```javascript
  const result = document.getElementById('result');
  
  function getApproval(){
      return new Promise((resolve,reject)=>{          setTimeout(()=>{
              resolve('approval!');
            },50);
    
      });
  }
  
  let approval = 'Not approved!';
  
  async function setApprovalText(){
    const approvalPromise = getApproval();
    result.textContent = await approvalPromise;
  };
  
  setApprovalText()
  
  ```

  上传页面上的一条博客，并显示返回内容到页面上

  js:

  ```
  // Get form elements
  const titleInput = document.getElementById('title');
  const contentInput = document.getElementById('content');
  const submitButton = document.getElementById('submit-button');
  
  const url = 'https://us-central1-open-classrooms-js-for-the-web.cloudfunctions.net/widgets';
  
  // Get DOM elements for showing response
  const responseMessage = document.getElementById('response-message');
  const responseTitle = document.getElementById('response-title');
  const responseId = document.getElementById('response-id');
  const responseContent = document.getElementById('response-content');
  
  submitButton.addEventListener('click', ($event) => {
    $event.preventDefault();
    const post = {
      title: titleInput.value,
      content: contentInput.value
    };
    submitFormData(post);
  });
  
  function makeRequest(data) {
    return new Promise((resolve, reject) => {
      let request = new XMLHttpRequest();
      request.open('POST', url + '/create-post');
      request.onreadystatechange = () => {
        if (request.readyState === 4) {
          if (request.status === 201) {
            resolve(JSON.parse(request.response));
          } else {
            reject(JSON.parse(request.response));
          }
        }
      };
      request.setRequestHeader('Content-Type', 'application/json');
      request.send(JSON.stringify(data));
    });
  }
  
  async function submitFormData(data){
    try{
      const response= await makeRequest(data);
    	responseMessage.textContent = response.message;
    	responseTitle.textContent = response.post.title;
    	responseId.textContent = response.post.id;
    	responseContent.textContent = response.post.content;
    }catch(errdata){
      responseMessage.textContent=errdata.error
    }
  }
  ```

  

  

* 事件监听方式处理

# 阿里云ECS

## 创建my sql服务

阿里云创建SSH密钥对

参考：https://help.aliyun.com/document_detail/51793.htm?spm=a2c4g.11186623.2.7.1def5bf0gsbV8H#concept-wy4-th1-ydb

# HTTP基础

## http缓存机制-NodeJS

### 强缓存策略

#### HTTP 1.0

expires

```

function updateTime(){   
    this.timmer=this.timmer||setInterval(() => 
        this.time= new Date().toUTCString()
    , 1000)
    return this.time
}
const http=require('http')
http.createServer((req,res)=>{
    const {url}=req
    if('/'===url){
        res.end(`
            <html>
                Http Update Time ${updateTime()}
                <script src='main.js'></script>
            </html>
        `)
    }else if('/main.js'===url){
        const content=`document.writeln('<br/> JS update time at ${updateTime()}')`
        //强缓存
        res.setHeader('Expires',new Date(Date.now()+10*1000).toUTCString())
        res.statusCode=200
        res.end(content)
    }
    else if('/favicon.ico'===url){
        res.end()
    }
}).listen(3000,()=>{
    console.log('http cache test run at port 3000')  
})
```



#### HTTP 1.1

cache-control

```
const content=`document.writeln('<br/> JS update time at ${updateTime()}')`
res.setHeader('Expires',new Date(Date.now()+10*1000).toUTCString())
res.setHeader('Cache-Control','max-age=20') //Cache-Control优先级高于Expires
```

### 协商缓存

expires和cache-control都会访问本地缓存直接验证是否过期，如果没过期直接使用本地缓存，并返回200。但如果设置了no-cache和no-store则本地缓存会被忽略，会去请求服务器验证资源是否更新，如果没有更新才继续使用本地缓存，此时返回304，这就是协商缓存。协商缓存主要包括last-modified和etag。

协商缓存简单的说就是浏览器和服务器就是否使用缓存在做协商。如果协商的结果是需要更新就返回200并返回更新内容。如果不需要只需要返回状态码304不用返回内容这样虽然需要后端应答但是不需要后端生成内容也不需要传输内容。依然可以享受缓存的种种好处。

#### lastmodified & if-Modified-Since

这是一组通过协商修改时间为基础的策略

![image-20210510135313934](D:\File\Learning-Resource\images\image-20210510135313934.png)

```
//协商缓存
res.setHeader('Cache-Control','no-cache')
res.setHeader('last-modified',new Date().toUTCString())
if(new Date(req.header['if-modified-since']).getTime()+3*1000>Date.now()){
	console.log('协商缓存命中、、')
	res.statusCode=304
	res.end()
	return
}
res.statusCode=200
res.end(content)
```

#### etag & if-none-match

该方法是通过内容判断，一般的做法是将内容进行摘要（Hash）,然后对比摘要来判断内容是否更新

![image-20210510141650516](D:\File\Learning-Resource\images\image-20210510141650516.png)

### ajax缓存

###  ServiceWork

